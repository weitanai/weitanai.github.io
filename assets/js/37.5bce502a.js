(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{237:function(t,a,n){"use strict";n.r(a);var s=n(0),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"函数式编程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程"}},[t._v("#")]),t._v(" 函数式编程")]),t._v(" "),n("h3",{attrs:{id:"_1-定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-定义"}},[t._v("#")]),t._v(" 1 定义")]),t._v(" "),n("h4",{attrs:{id:"不同的想法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#不同的想法"}},[t._v("#")]),t._v(" 不同的想法")]),t._v(" "),n("ul",[n("li",[n("p",[n("strong",[t._v("1 函数式编程关心数据的映射，命令式编程关心解决问题的步骤")])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("2 函数式编程关心类型（代数结构）之间的关系，命令式编程关心解决问题的步骤")])])]),t._v(" "),n("li",[n("p",[t._v("3 命令式编程是面向"),n("strong",[t._v("计算机硬件")]),t._v("的抽象，有"),n("strong",[t._v("变量")]),t._v("（对应着存储单元），"),n("strong",[t._v("赋值语句")]),t._v("（获取，存储指令）"),n("strong",[t._v("表达式")]),t._v("（内存引用和算术运算）和"),n("strong",[t._v("控制语句")]),t._v("（跳转指令），一句话，命令式程序就是一个"),n("strong",[t._v("冯诺依曼机")]),t._v("的"),n("strong",[t._v("指令序列")])])]),t._v(" "),n("li",[n("p",[t._v("而函数式编程是面向数学的抽象，将计算描述为一种"),n("strong",[t._v("表达式求值")]),t._v("，一句话，函数式程序就是一个"),n("strong",[t._v("表达式.")])])]),t._v(" "),n("li",[n("p",[t._v("函数式编程中的"),n("strong",[t._v("函数")]),t._v("这个术语不是指计算机中的函数（实际上是"),n("strong",[t._v("Subroutine")]),t._v("），而是指数学中的函数，即自变量的映射。就是说一个函数的值仅决定于函数参数的值，不依赖其他状态。比如sqrt(x)函数计算x的平方根，只要x不变，不论什么时候调用，调用几次，值都是不变的。")])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('模块复用和访存控制。         \n1. 模块复用“通过少量的表达式构造规则和灵活的表达式组合方式，可以构造足够实用、强大的程序语言。\n”变量、函数、对象、类型等等都是可以复用的程序元素。\n第一阶函数：函数可以被赋给变量，可以作为其他函数的参数、返回值。函数的复用更自由、方便。\n\n\n// JavaScript\nfunction outer() {\n    var x = 11;\n    function inner() {\n        x = x + 1;\n        console.log(x);\n    }\n\n    return inner; // 函数作为返回值\n}\n\n// 函数赋给变量 \nvar test = outer();\n\n\n抽象数据类型：在处理递归结构时方便很多（如数据结构中的树，编译器的Parser等）\n以TAPL第三章untyped arith语言的解释器为例（部分）(* Ocaml *)\ntype term =\n    TmTrue of info \n  | TmFalse of info \n  | TmIf of info * term * term * term \n  | TmSucc of info * term\n  | TmPred of info * term \n  | TmIsZero of info * term // Scala      \n// case class/object可以实现ADT\nsealed trait Term         \ncase object TmTrue extends Term \ncase object TmFalse extends Term\ncase class TmIf(cond: Term, t1: Term, t2: Term) extends Term\ncase object TmZero extends Term \ncase class TmPred(t: Term) extends Term \ncase class TmIsZero(t: Term) extends Term在ML、Haskell等语言中，\n递归函数、数据结构的定义往往会用到模式匹配 语法模式匹配通常比if-else和switch更强大、高效。\n（注：初学者在使用时常犯错误多样化的多态函数重载（ad-hoc多态）、泛型（参数化多态）和subtyping。\nHaskell的typeclass，Ocaml的Module system，Common lisp的mutiple dispatch。。。\n当然，C++的模板+模板特化可以模拟typeclass，Java不也有泛型么（黑）。。\n\n\n2. 访存控制 变量的不可变性"Aliasing+mutation=>内存问题，aliasing+mutation+ordering=>数据竞争。\n想要安全，就应该要么消除aliasing，要么消除mutation。"纯函数式语言如Haskell，\n号称“变量的不可变性”（immutable)，即只绑定一次，完全无副作用。\n这种理念影响了Scala、Rust等现代语言如Scala中val和var的区别，\n标准库分别提供immutable和mutable collections。\n类型相关的权限dynamic type一时爽。\n当然Scheme/Clojure等语言也是动态类型的。。这里要强调的是静态强类型。在函数式语言中它得到了充分的发展。\n前面讨论的内容可能并不限于“函数式”，也必然有些内容未涉及。\n待补充。。程序复用和权限控制，在命令式、面向对象中也有，\n但是函数式语言中它们做得更极致，或者说，给了人们新的视角：为什么一定要把函数放在类中（Java），\n为什么要函数指针用多了那么别扭（C），\n为什么有些设计模式实现起来那么地“绕”，为什么不能摆脱和锁的斗争。。\n')])])]),n("h4",{attrs:{id:"什么是函数式编程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是函数式编程"}},[t._v("#")]),t._v(" 什么是函数式编程")]),t._v(" "),n("p",[t._v("函数式编程是一种编程范式，主要是利用函数把运算过程封装起来，通过组合各种函数来计算结果。函数式编程意味着你可以在更短的时间内编写具有更少错误的代码。举个简单的例子，假设我们要把字符串 "),n("code",[t._v("functional programming is great")]),t._v(" 变成每个单词首字母大写，我们可以这样实现：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var string = 'functional programming is great';\nvar result = string\n  .split(' ')\n  .map(v => v.slice(0, 1).toUpperCase() + v.slice(1))\n  .join(' ');\n")])])]),n("p",[t._v("上面的例子先用 split 把字符串转换数组，然后再通过 map 把各元素的首字母转换成大写，最后通过 join 把数组转换成字符串。 整个过程就是 "),n("code",[t._v("join(map(split(str)))")]),t._v(",体现了函数式编程的核心思想： "),n("strong",[t._v("通过函数对数据进行转换")]),t._v("。")]),t._v(" "),n("p",[t._v("由此我们可以得到，函数式编程有两个基本特点：")]),t._v(" "),n("ul",[n("li",[t._v("通过函数来对数据进行转换")]),t._v(" "),n("li",[t._v("通过串联多个函数来求结果")])]),t._v(" "),n("hr"),t._v(" "),n("h3",{attrs:{id:"_2-好处"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-好处"}},[t._v("#")]),t._v(" 2 好处")]),t._v(" "),n("h4",{attrs:{id:"_1-无副作用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-无副作用"}},[t._v("#")]),t._v(" 1 无副作用")]),t._v(" "),n("p",[t._v("指调用函数时不会修改外部状态，即一个函数调用 n 次后依然返回同样的结果。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var a = 1;\n// 含有副作用，它修改了外部变量 a\n// 多次调用结果不一样\nfunction test1() {\n  a++\n  return a;\n}\n// 无副作用，没有修改外部状态\n// 多次调用结果一样\nfunction test2(a) {\n  return a + 1;\n}\n")])])]),n("h3",{attrs:{id:""}},[n("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])]),t._v(" "),n("h4",{attrs:{id:"_2-透明引用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-透明引用"}},[t._v("#")]),t._v(" 2 透明引用")]),t._v(" "),n("p",[t._v("指一个函数只会用到传递给它的变量以及自己内部创建的变量，不会使用到其他变量。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var a = 1;\nvar b = 2;\n// 函数内部使用的变量并不属于它的作用域\nfunction test1() {\n  return a + b;\n}\n// 函数内部使用的变量是显式传递进去的\nfunction test2(a, b) {\n  return a + b;\n}\n")])])]),n("h3",{attrs:{id:"-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#-2"}},[t._v("#")])]),t._v(" "),n("h4",{attrs:{id:"-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#-3"}},[t._v("#")])]),t._v(" "),n("h4",{attrs:{id:"_3不可变变量"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3不可变变量"}},[t._v("#")]),t._v(" 3不可变变量")]),t._v(" "),n("ul",[n("li",[t._v("由于（多个线程之间）不共享状态，不会造成"),n("strong",[t._v("资源争用(Race condition)")]),t._v("，也就不需要用"),n("strong",[t._v("锁")]),t._v("来保护可变状态，也就不会出现"),n("strong",[t._v("死锁")])]),t._v(" "),n("li",[t._v("这样可以更好地并发起来，尤其是在"),n("strong",[t._v("对称多处理器")]),t._v("（SMP）架构下能够更好地利用多个处理器（核）提供的并行处理能力")])]),t._v(" "),n("p",[t._v("指的是一个变量一旦创建后，就不能再进行修改，任何修改都会生成一个新的变量。使用不可变变量最大的好处是线程安全。多个线程可以同时访问同一个不可变变量，让并行变得更容易实现。 由于 JavaScript 原生不支持不可变变量，需要通过第三方库来实现。 (如 Immutable.js，Mori 等等)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var obj = Immutable({ a: 1 });\nvar obj2 = obj.set('a', 2);\nconsole.log(obj);  // Immutable({ a: 1 })\nconsole.log(obj2); // Immutable({ a: 2 })\n")])])]),n("h4",{attrs:{id:"_4-新特性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-新特性"}},[t._v("#")]),t._v(" 4  新特性")]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("高阶函数（Higher-order function）")])]),t._v(" "),n("li",[n("strong",[t._v("偏应用函数（Partially Applied Functions）")])]),t._v(" "),n("li",[n("strong",[t._v("柯里化（Currying）")])]),t._v(" "),n("li",[n("strong",[t._v("闭包（Closure）")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);