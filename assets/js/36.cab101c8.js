(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{236:function(e,r,s){"use strict";s.r(r);var n=s(0),t=Object(n.a)({},(function(){var e=this,r=e.$createElement,s=e._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"可复用中间件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可复用中间件"}},[e._v("#")]),e._v(" 可复用中间件")]),e._v(" "),s("h3",{attrs:{id:"_1-通用crud接口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-通用crud接口"}},[e._v("#")]),e._v(" 1 通用CRUD接口")]),e._v(" "),s("ul",[s("li",[e._v("通用性")]),e._v(" "),s("li",[e._v("可扩展性")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 后端 api, 把不同url 当作\n\nmodule.exports = options => {\n  return async (req, res, next) => {\n    const modelName = require('inflection').classify(req.params.resource)\n    // 解析req.params.resource的model为大写匹配models定义的名字\n    req.Model = require(`../models/${modelName}`)\n    // 挂载到req上， 让以后的操作找到models的名字\n    next()\n  }\n}\n\n、\n  const resourceMiddleware = require('../../middleware/resource')\n  app.use('/admin/api/rest/:resource',  resourceMiddleware(), router)\n  \n  //'/admin/api/rest/:resource' => 动态传入路径，\n\nrouter.post('/', async (req, res) => {\n    const model = await req.Model.create(req.body)\n    res.send(model)\n  })\n")])])]),s("ol",[s("li",[e._v("前端的相同的业务逻辑比如上传数据， 创建数据，")]),e._v(" "),s("li",[e._v("后端统一接口， 解析req 的model, 动态调用mongoose创造的model去创建数据。")])])])}),[],!1,null,null,null);r.default=t.exports}}]);